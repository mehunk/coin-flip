// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.19;

import {VRFConsumerBaseV2Plus} from '@chainlink/contracts/src/v0.8/vrf/dev/VRFConsumerBaseV2Plus.sol';
import {VRFV2PlusClient} from '@chainlink/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol';

import './PriceConverter.sol';

error CoinFlip__InsufficientWager();
error CoinFlip__InvalidRequestId();
error CoinFlip__TransferPriceFailed();

/// @title CoinFlip
/// @author mehunk
/// @notice You can use this contract for only the most basic simulation
/// @dev All function calls are currently implemented with mock
/// @custom:experimental This is an experimental contract.
/// @custom:todo withdraw function
/// @custom:todo store the owner
contract CoinFlip is VRFConsumerBaseV2Plus {
  using PriceConverter for uint256;

  struct Player {
    address addr;
    bool heads;
    uint256 amount;
  }

  /// @notice 1 USD with 18 decimals
  uint256 public constant MINIMUM_USD = 1e18;

  uint16 constant REQUEST_CONFIRMATIONS = 3;

  uint32 constant CALLBACK_GAS_LIMIT = 100000;

  uint32 constant NUM_WORDS = 1;

  uint256 immutable s_subscriptionId;

  bytes32 immutable s_keyHash;

  AggregatorV3Interface immutable s_priceFeed;

  mapping(uint256 => Player) private s_requestId2Player;

  event Flipped(address sender, uint256 requestId);

  event Landed(address sender, uint256 requestId, bool won, uint256 amount);

  constructor(
    address priceFeedAddress,
    uint256 subscriptionId,
    address vrfCoordinator,
    bytes32 keyHash
  ) VRFConsumerBaseV2Plus(vrfCoordinator) {
    s_priceFeed = AggregatorV3Interface(priceFeedAddress);
    s_keyHash = keyHash;
    s_subscriptionId = subscriptionId;
  }

  fallback() external payable {}

  receive() external payable {}

  /// Place bets, then request random words via VRF
  /// @param heads Heads or tails, true for heads and false for tails
  function flipCoin(bool heads) external payable {
    if (msg.value.getConversionRate(s_priceFeed) < MINIMUM_USD) {
      revert CoinFlip__InsufficientWager();
    }

    uint256 requestId = s_vrfCoordinator.requestRandomWords(
      VRFV2PlusClient.RandomWordsRequest({
        keyHash: s_keyHash,
        subId: s_subscriptionId,
        requestConfirmations: REQUEST_CONFIRMATIONS,
        callbackGasLimit: CALLBACK_GAS_LIMIT,
        numWords: NUM_WORDS,
        extraArgs: VRFV2PlusClient._argsToBytes(
          VRFV2PlusClient.ExtraArgsV1({nativePayment: false})
        )
      })
    );

    s_requestId2Player[requestId] = Player(msg.sender, heads, msg.value);

    emit Flipped(msg.sender, requestId);
  }

  /// Callback function which is called by VRF
  /// @param requestId The requestId returned by VRF
  /// @param randomWords The random words generated by VRF
  function fulfillRandomWords(
    uint256 requestId,
    uint256[] calldata randomWords
  ) internal override {
    bool _heads = randomWords[0] % 2 == 1;

    onLanding(_heads, requestId);
  }

  /// Handle the game result, if the player wins, then transfer prize
  /// @param _heads The game result(is heads or not) generated by VRF
  /// @param requestId The requestId returned by VRF
  function onLanding(bool _heads, uint256 requestId) private {
    Player memory player = s_requestId2Player[requestId];

    if (player.addr == address(0)) {
      revert CoinFlip__InvalidRequestId();
    }

    bool result = player.heads == _heads;

    uint256 amount = 0;

    if (result) {
      amount = player.amount * 2;

      (bool callSuccess, ) = payable(player.addr).call{value: amount}('');

      if (!callSuccess) {
        revert CoinFlip__TransferPriceFailed();
      }
    }

    emit Landed(player.addr, requestId, result, amount);
  }

  function getPriceFeed() public view returns (AggregatorV3Interface) {
    return s_priceFeed;
  }
}
