import { loadFixture } from '@nomicfoundation/hardhat-toolbox-viem/network-helpers'
import { expect, assert } from 'chai'
import hre from 'hardhat'
import { parseEther, parseEventLogs, getContract } from 'viem'

import {
  DECIMALS,
  INITIAL_ANSWER,
  BASE_FEE,
  GAS_PRICE_LINK,
  WEI_PER_UNIT_LINK,
  FUND_SUBSCRIPTION_AMOUNT,
  KEY_HASH,
} from '../constants'

type GameResult = {
  requestId?: bigint
  won?: boolean
  amount?: bigint
}

const WAGER = parseEther('0.001')

async function deployVRFCoordinatorV2_5Mock() {
  const publicClient = await hre.viem.getPublicClient()

  const vrfCoordinatorV2_5Mock = await hre.viem.deployContract(
    'VRFCoordinatorV2_5Mock',
    [BASE_FEE, GAS_PRICE_LINK, WEI_PER_UNIT_LINK]
  )

  const hash = await vrfCoordinatorV2_5Mock.write.createSubscription()
  const txReceipt = await publicClient.waitForTransactionReceipt({ hash })

  const subscriptionCreatedEvents = parseEventLogs({
    eventName: 'SubscriptionCreated',
    logs: txReceipt.logs,
    abi: vrfCoordinatorV2_5Mock.abi,
  })

  const { subId } = subscriptionCreatedEvents[0].args
  await vrfCoordinatorV2_5Mock.write.fundSubscription([
    subId,
    FUND_SUBSCRIPTION_AMOUNT,
  ])

  return {
    vrfCoordinatorV2_5Mock,
    subId,
  }
}

describe('CoinFlip', function () {
  async function deployCoinFlipFixture() {
    const publicClient = await hre.viem.getPublicClient()
    const [deployer, player] = await hre.viem.getWalletClients()

    const mockV3Aggregator = await hre.viem.deployContract('MockV3Aggregator', [
      DECIMALS,
      INITIAL_ANSWER,
    ])

    const { vrfCoordinatorV2_5Mock, subId } =
      await deployVRFCoordinatorV2_5Mock()

    const coinFlip = await hre.viem.deployContract('CoinFlip', [
      mockV3Aggregator.address,
      subId,
      vrfCoordinatorV2_5Mock.address,
      KEY_HASH,
    ])

    await vrfCoordinatorV2_5Mock.write.addConsumer([subId, coinFlip.address])

    await deployer.sendTransaction({
      to: coinFlip.address,
      value: parseEther('1.0'),
    })

    return {
      publicClient,
      deployer,
      player,
      coinFlip,
      vrfCoordinatorV2_5Mock,
    }
  }

  async function getRequestIdFixture() {
    const { publicClient, deployer, player, coinFlip, vrfCoordinatorV2_5Mock } =
      await loadFixture(deployCoinFlipFixture)

    // Use the player's wallet to connect contract
    const playerCoinFlip = getContract({
      address: coinFlip.address,
      abi: coinFlip.abi,
      client: { public: publicClient, wallet: player },
    })

    // Player places bets
    const hash = await playerCoinFlip.write.flipCoin([true], {
      value: WAGER,
    })

    const txReceipt = await publicClient.waitForTransactionReceipt({ hash })

    const events = parseEventLogs({
      eventName: 'Flipped',
      logs: txReceipt.logs,
      abi: coinFlip.abi,
    })

    expect(events).to.have.length(1)

    const { requestId } = events[0].args

    return {
      publicClient,
      deployer,
      player,
      coinFlip,
      playerCoinFlip,
      vrfCoordinatorV2_5Mock,
      requestId,
    }
  }

  describe('flipCoin', () => {
    it("Should fail if you don't send enough ETH", async () => {
      const { coinFlip } = await loadFixture(deployCoinFlipFixture)

      await expect(
        coinFlip.write.flipCoin([true], {
          value: parseEther('0.0001'),
        })
      ).to.be.rejectedWith('CoinFlip__InsufficientWager()')
    })

    it('Should get requestId', async () => {
      const { requestId } = await loadFixture(getRequestIdFixture)

      assert(requestId > 0n)
    })
  })

  describe('fulfillRandomWords', () => {
    it('Should win if the guess is the same as random word generated by VRF', async () => {
      const {
        publicClient,
        player,
        coinFlip,
        vrfCoordinatorV2_5Mock,
        requestId,
      } = await loadFixture(getRequestIdFixture)

      const startingPlayerBalance = await publicClient.getBalance({
        address: player.account.address,
      })

      const hash =
        await vrfCoordinatorV2_5Mock.write.fulfillRandomWordsWithOverride([
          requestId,
          coinFlip.address,
          [1n],
        ])

      const txReceipt = await publicClient.waitForTransactionReceipt({ hash })

      assert(txReceipt)

      const waitForLandedEvent = () => {
        return new Promise<GameResult>(async (resolve) => {
          coinFlip.watchEvent.Landed({
            onLogs: (logs) => {
              resolve(logs[0].args)
            },
          })
        })
      }

      const {
        won,
        amount,
        requestId: resultRequestId,
      } = await waitForLandedEvent()

      const endingPlayerBalance = await publicClient.getBalance({
        address: player.account.address,
      })

      assert(resultRequestId === requestId)
      assert(won)
      assert(amount === WAGER * 2n)
      assert(endingPlayerBalance === startingPlayerBalance + WAGER * 2n)
    })

    it('Should lose if the guess is different from the random word generated by VRF', async function () {
      const {
        publicClient,
        player,
        coinFlip,
        vrfCoordinatorV2_5Mock,
        requestId,
      } = await loadFixture(getRequestIdFixture)

      const startingPlayerBalance = await publicClient.getBalance({
        address: player.account.address,
      })

      const hash =
        await vrfCoordinatorV2_5Mock.write.fulfillRandomWordsWithOverride([
          requestId,
          coinFlip.address,
          [0n],
        ])

      const txReceipt = await publicClient.waitForTransactionReceipt({ hash })

      assert(txReceipt)

      const waitForLandedEvent = () => {
        return new Promise<GameResult>(async (resolve) => {
          coinFlip.watchEvent.Landed({
            onLogs: (logs) => {
              resolve(logs[0].args)
            },
          })
        })
      }

      const {
        won,
        amount,
        requestId: resultRequestId,
      } = await waitForLandedEvent()

      const endingPlayerBalance = await publicClient.getBalance({
        address: player.account.address,
      })

      assert(resultRequestId === requestId)
      assert(!won)
      assert(amount === 0n)
      assert(endingPlayerBalance === startingPlayerBalance)
    })
  })
})
